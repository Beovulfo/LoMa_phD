import pylab
from math  import *
#from pylab import *
from numpy import *


def create_filenames(varname,nsteps,rksteps=3):
	""" filenames  = create_filenames(varname,nsteps,*rksteps) 
	    list       = create_filenames(str, int)
	    returns a list of filenames live varname.+001001,001002,...,nsteps/003
	Ex:
	print create_filenames("v00.", 2,0)
        >>> ['v00.001','v00.002']	
	"""
	filenames=[]
	for istep in range(nsteps):
		if rksteps != 0:
    			for rkstep in range(rksteps):
        			filename=  varname +'%03d' % (istep+1) + '%03d' % (rkstep+1)
				filenames.append(filename)
		else:
        		filename=  varname +'%03d' % (istep+1)
			filenames.append(filename)
	return filenames

def create_stanames(varname,nstepi,nstepf):
	""" filenames  = create_stanames(varname,nstepi,nstepf) 
	    list       = create_stanames(str, int,int)
	    returns a list of filenames live varname_045.sta'
	Ex:
	print create_stanames("v00.",20,21)
        >>> ['v00_020.sta','v00_021.sta']	
	"""
	filenames=[]
	for istep in range(nstepi,nstepf):
       		filename=  varname +'_'+'%03d' % (istep+1)+'.sta'
		filenames.append(filename)
	return filenames

#----------------------------------------------------
def create_spenames(varname,run,nstepi,nstepf):
	""" filenames = create_stanames(varname,run,nstepi,nstepf) 
	    list      = create_stanames(str,int, int,int)
	    returns a list of filenames like varname_01_045.spe'
	Ex:
	print create_spenames("v00.",20,21)
        >>> ['v00_01_020.spe','v00_01_021.spe']	
	"""
	filenames=[]
	for istep in range(nstepi,nstepf):
       		filename=  varname +'_' + \
		'%02d' % run +      '_' + \
		'%03d' % (istep+1)+'.spe'
		filenames.append(filename)
	return filenames

#-----------------------------------------------------------------------------------------------------#
def readASCII(filename):
	""" open a text file with "ncolumns"
	 and reads data, returns a list of lists
	 Important: data must be numbers only and same columns for all lines! 
	[list] = readASCII([str])
	"""
	import numpy as np
	f1 = open(filename,'r')
	file = f1.readlines()
	f1.close()
	#Take one line for info
	ncolumns= len(file[0].split()) 
	nlines = len(file)
	print "Reading file of %s lines and %s columns" %(nlines,ncolumns)
	x = [[] for i in range(ncolumns)]	
	for line in file:
		row = line.split()
		for col in range(len(row)):
			x[col].append(float(row[col].replace('D','E')))
	#return x
	return np.array(x)
			
			
def makeplot(x,col1=0,col2=1):
	import pylab as pl
	fig = pl.figure()
	pl.plot(x[col1,:],x[col2,:],'go')
	#fig.show()
	pl.show()
	print 'Continue computation'

def readfield(filename,my=513):
	""" This function reads the typical unformatted output generated by LOMA
	This case works for SCALAR
	(y,field,u00,w00) = readfield(filename,my)
	(array,array[nxplanes,mz,my,2])= readfield (str,int)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),\
		('mx','uint32'),('my','uint32'),('mz','uint32'),\
		('yfmap',yfmap,my), \
		('uw00',uw00,my),\
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mx=RECORD1['mx']
	my=RECORD1['my']
	mz=RECORD1['mz']
	ntotr=2*my*mz
	#Create type "recplane"
	recplane = np.dtype([('dummy1','uint32'), \
                 ('data','float32',ntotr), \
                 ('dummy2','uint32')])

	#Read all planes info
	nplanes=mx//2
	FIELD=np.ndarray(shape=(nplanes,mz,my,2),\
		 dtype=float, order='F')
	FIELD.shape
	for i in range(nplanes):
    		readrec = np.fromfile(f,recplane,1)
    		planedata = readrec['data']
    		planedata.shape=(mz,my,2)
    		FIELD[i,:,:]=planedata

	f.close()
	#Return y, FIELD
	return RECORD1['yfmap']['y'][0,:],FIELD,RECORD1['uw00']['u00'][0,:],\
 	RECORD1['uw00']['w00'][0,:]

def read2field(filename,my=513):
	""" This function reads the typical unformatted output generated by LOMA
	This case works for output files (classic vor/phi)
	(y,vor,phi,u00,w00) = read2field(filename,my)
	(array,array[nxplanes,mz,my,2],array[nxplanes,mz,my,2],array(my,2),array(my,2) = read2field (str,int)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),\
		('mx','uint32'),('my','uint32'),('mz','uint32'),\
		('yfmap',yfmap,my), \
		('uw00',uw00,my),
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mx=RECORD1['mx']
	my=RECORD1['my']
	mz=RECORD1['mz']
	ntotr=4*my*mz
	#Create type "recplane"
	recplane = np.dtype([('dummy1','uint32'), \
                 ('data','float32',ntotr), \
                 ('dummy2','uint32')])

	#Read all planes info
	nplanes=mx//2
	FIELD1=np.ndarray(shape=(nplanes,mz,my,2),\
		 dtype=float, order='F')
	FIELD2=np.ndarray(shape=(nplanes,mz,my,2),\
		 dtype=float, order='F')
	for i in range(nplanes):
    		readrec = np.fromfile(f,recplane,1)
    		planedata = readrec['data']
    		planedata.shape=(mz,my,4)
		vor = planedata[:,:,0:2]
		vor.shape=(mz,my,2)
		phi = planedata[:,:,2:4]
		phi.shape=(mz,my,2)
    		FIELD1[i,:]=vor
    		FIELD2[i,:]=phi

	f.close()
        print 'Data from time = %s' % RECORD1['time']
        print 'mx = %s, my = %s, mz = %s' % (RECORD1['mx'],RECORD1['my'],RECORD1['mz'])
	#Return y, FIELD
	return RECORD1['yfmap']['y'][0,:],FIELD1,FIELD2,RECORD1['uw00']['u00'], RECORD1['uw00']['w00']

#===============================================================#

def readsta(filename,opt=1):
	""" This function reads the sta file generated by LOMA
#(y,um,vm,wm,rum,rvm,rwm,Tm,w1m,w2m,w3m,up,vp,wp,uvr,uwr,vwr,w1p,w2p,w3p,Tp) = readsta(filename)
        um,vm,wm,urms,vrms,wrms,uv = readsta(..)
        "..p" variables mean square of the variables (energy)
	(Nvar x array[my]) = readsta (str)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('my','uint32'),
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),('nacum','uint32'), \
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)
	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD1...!"
	#else:
    	#	print "Fiel read correctly :)"
        #Save "my"
	my=RECORD1['my']

        rec2 = np.dtype([('dummy1','uint32'), \
		('yfmap',yfmap,my), \
		('dummy2','uint32')])
	RECORD2=np.fromfile(f,rec2,1)

	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD2...!"
	#else:
    		#print "Fiel read correctly :)"
	#Save y array
	y = RECORD2['yfmap']['y'][0,]
        #Need to create stats dtype
	if opt==0: #Last version without ruu,ruv...
		stats = np.dtype([('um','float64'), \
			('vm' ,'float64'), \
			('wm' ,'float64'), \
	                ('rum','float64'), \
	                ('rvm','float64'), \
	                ('rwm','float64'), \
	                ('Tm' ,'float64'), \
	                ('w1m','float64'), \
	                ('w2m','float64'), \
	                ('w3m','float64'), \
	                ('up' ,'float64'), \
	                ('vp' ,'float64'), \
	                ('wp' ,'float64'), \
	                ('uvr','float64'), \
	                ('uwr','float64'), \
	                ('vwr','float64'), \
	                ('w1p','float64'), \
	                ('w2p','float64'), \
	                ('w3p','float64'), \
	                ('Tp','float64'), \
	                ('ep','float64')])
	else:
		stats = np.dtype([('um','float64'), \
			('vm' ,'float64'), \
			('wm' ,'float64'), \
	                ('rum','float64'), \
	                ('rvm','float64'), \
	                ('rwm','float64'), \
	                ('Tm' ,'float64'), \
	                ('w1m','float64'), \
	                ('w2m','float64'), \
	                ('w3m','float64'), \
	                ('up' ,'float64'), \
	                ('vp' ,'float64'), \
	                ('wp' ,'float64'), \
	                ('uvr','float64'), \
	                ('uwr','float64'), \
	                ('vwr','float64'), \
	                ('w1p','float64'), \
	                ('w2p','float64'), \
	                ('w3p','float64'), \
	                ('Tp','float64'), \
	                ('ep','float64'), \
	                ('ruu','float64'), \
	                ('ruv','float64'), \
	                ('ruw','float64'), \
	                ('rvv','float64'), \
	                ('rvw','float64'), \
	                ('rww','float64'), \
					])


	nacum = RECORD1['nacum']
	#Create type "recstats"
	recstats = np.dtype([('dummy1','uint32'), \
	 	('data',stats,my), \
		('dummy2','uint32')])

	DATA=np.fromfile(f,recstats,1)
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for STATS...!"
	#else:
    	#	print "Fiel read correctly for STATS :)"
	f.close()
        um = DATA['data']['um'][0,:]/nacum 
        vm = DATA['data']['vm'][0,:]/nacum
        wm = DATA['data']['wm'][0,:]/nacum
	uu = DATA['data']['up'][0,:]/nacum
	vv = DATA['data']['vp'][0,:]/nacum
	ww = DATA['data']['wp'][0,:]/nacum
        rum = DATA['data']['rum'][0,:]/nacum
        rvm = DATA['data']['rvm'][0,:]/nacum
        rwm = DATA['data']['rwm'][0,:]/nacum
        urms = (abs(uu-um**2))**0.5
        vrms = (abs(vv-vm**2))**0.5
        wrms = (abs(ww-wm**2))**0.5
        uv = DATA['data']['uvr'][0,:]/nacum
        uv =uv - um*vm
        uw = DATA['data']['uwr'][0,:]/nacum
        uw =uw - um*wm
        vw = DATA['data']['vwr'][0,:]/nacum
        vw =vw - vm*wm
	w3p = DATA['data']['w3p'][0,:]/nacum
	w2p = DATA['data']['w2p'][0,:]/nacum
	w1p = DATA['data']['w1p'][0,:]/nacum

        Tm = DATA['data']['Tm'][0,:]/nacum
	TT = DATA['data']['Tp'][0,:]/nacum
        ep = DATA['data']['ep'][0.:]/nacum
	if opt > 0:
        	ruu = DATA['data']['ruu'][0,:]/nacum
        	ruv = DATA['data']['ruv'][0,:]/nacum
        	ruw = DATA['data']['ruw'][0,:]/nacum
        	rvv = DATA['data']['rvv'][0,:]/nacum
        	rvw = DATA['data']['rvw'][0,:]/nacum
        	rww = DATA['data']['rww'][0,:]/nacum
	else:
		ruu = DATA['data']['up'][0,:]/nacum
		rvv = DATA['data']['vp'][0,:]/nacum
		rww = DATA['data']['wp'][0,:]/nacum
		ruv = DATA['data']['uvr'][0,:]/nacum
		ruw = DATA['data']['uwr'][0,:]/nacum
		rvw = DATA['data']['vwr'][0,:]/nacum
	
	#Return all
	return y,                \
	RECORD1['time'][0],         \
	{'um':um,'vm':vm,'wm':wm,'urms':urms,'vrms':vrms,'wrms':wrms,'uv':uv,'TT':TT, \
	'w1p':w1p,'w2p':w2p,'w3p':w3p, \
	'Tm':Tm,'ep':ep,'rum':rum,'rvm':rvm,'rwm':rwm,'ruu':ruu,'ruv':ruv,'ruw':ruw,'rvv':rvv,'rvw':rvw,'rww':rww,'nacum':nacum}
	#DATA['data']['rum'][0,:],\
	#DATA['data']['rvm'][0,:],\
	#DATA['data']['rwm'][0,:],\
	#DATA['data']['Tm'][0,:], \
	#DATA['data']['w1m'][0,:],\
	#DATA['data']['w2m'][0,:],\
	#DATA['data']['w3m'][0,:],\
	#DATA['data']['uwr'][0,:],\
	#DATA['data']['vwr'][0,:],\
	#DATA['data']['w1p'][0,:],\
	#DATA['data']['w2p'][0,:],\
	#DATA['data']['w3p'][0,:],\
	#DATA['data']['Tp'][0,:]

#(y,um,vm,wm,rum,rvm,rwm,Tm,w1m,w2m,w3m,up,vp,wp,uvr,uwr,vwr,w1p,w2p,w3p,Tp) = readfield(filename,my)


def readfieldxz(filename):
	""" 
	This function reads the XZ field generated by TOFIS fortran program.
	(y(jspecy),field,xvec,zvec) = readfieldxz(filename)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	#uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('mgalx','uint32'),('my','uint32'),('mgalz','uint32'),\
		('nspec','uint32'),('nacum','uint32'),\
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mgalx=RECORD1['mgalx'][0]
	my=RECORD1['my'][0]
	mgalz=RECORD1['mgalz'][0]
	nspec=RECORD1['nspec'][0]


	print "nspec= %s" % nspec

	rec2 = np.dtype([('dummy1','uint32'), \
 		('jspecy','uint32',nspec),  \
		('yfmap',yfmap,my),	\
		('dummy2','uint32')])
	#READ record2
	RECORD2=np.fromfile(f,rec2,1)

	#Check if record2 is ok...
	if RECORD2['dummy1'] != RECORD2['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	#Save y vector amd jspecy
	y = RECORD2['yfmap']['y'][0,]
        jspecy = RECORD2['jspecy'][0,]



	#Create type "recplane"
	recplaney = np.dtype([('dummy1','uint32'), \
                 ('data','float32',mgalx*mgalz), \
                 ('dummy2','uint32')])

	#Read all planes Y info
	FIELD1=np.ndarray(shape=(nspec,mgalx*mgalz),\
	dtype=float, order='F')
	for j in range(nspec):
    		readrec = np.fromfile(f,recplaney,1)
    		planeydata = readrec['data']
    		#planeydata.shape=(mgalz,mgalx)
		FIELD1[j,:] = planeydata[:]
		#FIELD1[j,:,:] = planeydata[:,:]
        FIELD1.shape=(nspec,mgalz,mgalx)
	FIELD1=FIELD1.transpose(2,0,1)
	f.close()
        #Create vector X and Z
	Lx = 2*3.1415/RECORD1['alp']
	Lz = 2*3.1415/RECORD1['bet']
	x = np.linspace(-Lx/2.,Lx/2.,mgalx)
	z = np.linspace(-Lz/2.,Lz/2.,mgalz)

        print 'Data from time = %s' % RECORD1['time']
        print 'mgalx = %s, my = %s, mgalz = %s' % (RECORD1['mgalx'], \
		RECORD1['my'],RECORD1['mgalz'])
	#Return y, FIELD
	return RECORD2['yfmap']['y'][0,jspecy-1],jspecy,FIELD1,x,z

#===============================================================#


def readfieldyz(filename):
	""" 
	This function reads the YZ field generated by TOFIS fortran program.
	(field,yvec,zvec) = readfieldxz(filename)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	#uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('mgalx','uint32'),('my','uint32'),('mgalz','uint32'),\
		('nspec','uint32'),('nacum','uint32'),\
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mgalx=RECORD1['mgalx'][0]
	my=RECORD1['my'][0]
	mgalz=RECORD1['mgalz'][0]
	nspec=RECORD1['nspec'][0]

	print "nspec= %s" % nspec

	rec2 = np.dtype([('dummy1','uint32'), \
 		('jspecy','uint32',nspec),  \
		('yfmap',yfmap,my),	\
		('dummy2','uint32')])
	#READ record2
	RECORD2=np.fromfile(f,rec2,1)

	#Check if record2 is ok...
	if RECORD2['dummy1'] != RECORD2['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	#Save y vector amd jspecy
	y = RECORD2['yfmap']['y'][0,]
        jspecy = RECORD2['jspecy'][0,]



	#Create type "recplane"
	rectZ = np.dtype([('dummy1','uint32'), \
                 ('data','float32',mgalz), \
                 ('dummy2','uint32')])

	#Read all planes Y info
	FIELD1=np.ndarray(shape=(mgalz,my),\
		 dtype=float, order='F')
	for j in range(my):
    		readrec = np.fromfile(f,rectZ,1)
    		rectZdata = readrec['data']
		FIELD1[:,j] = rectZdata[0,:]

	f.close()
        #Create vector X and Z
	Lx = 2*3.1415/RECORD1['alp']
	Lz = 2*3.1415/RECORD1['bet']
	x = np.linspace(-Lx/2.,Lx/2.,mgalx)
	z = np.linspace(-Lz/2.,Lz/2.,mgalz)

        print 'Data from time = %s' % RECORD1['time']
        print 'mgalx = %s, my = %s, mgalz = %s' % (RECORD1['mgalx'], \
		RECORD1['my'],RECORD1['mgalz'])
	#Return y, FIELD
	return FIELD1,RECORD2['yfmap']['y'][0,:],z

#===============================================================#
def read4field(filename,my=513):
	""" This function reads the typical unformatted output generated by LOMACTE
	This case works for output files (classic vor/phi)
	(y,vor,phi,psi,scal,u00,v00,w00) = read4field(filename,my)
	(array,array[nxplanes,mz,my,2],array[nxplanes,mz,my,2],array(my,2),array(my,2) = read4field (str,int)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	uvw00 = np.dtype([('u00','float32'),('v00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),\
		('mx','uint32'),('my','uint32'),('mz','uint32'),\
		('yfmap',yfmap,my), \
		('uvw00',uvw00,my),
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD1...!"
                print "Re = %s " % RECORD1['Re']
                print "alp = %s " % RECORD1['alp']
                print "bet = %s " % RECORD1['bet']
                print "a0 = %s " % RECORD1['a0']
	else:
    		print "Fiel read correctly :)"

	mx=RECORD1['mx']
	my=RECORD1['my']
	mz=RECORD1['mz']
	ntotr  = 8*my*mz
        nfield = 2*my*mz
        #plane = np.ndarray(shape=(4,2*my,mz),dtype=float,order='F')
	#Create type "recplane"
	recplane = np.dtype([('dummy1','uint32'), \
                 ( 'data','float32',ntotr), \
                 ('dummy2','uint32')])

	#Read all planes info
	nplanes=mx//2

	temp1 = np.zeros(4*2*my*mz)
	temp2 = np.ndarray(shape=(4,2*my,mz),\
		 dtype=float, order='F')
	VOR = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')
	PHI = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')
	PSI = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')
	SCAL = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')

	for i in range(nplanes):
		readrec = np.fromfile(f,recplane,1)
		if recplane['dummy1'] != recplane['dummy2']:
			print "File read not good for plane %s ...!" % i
		else:
    			print "Fiel read correctly for plane %s :)" % i
		temp1 = readrec['data'][:]
		temp2 = np.reshape(temp1,(4,2*my,mz),order='F')
		VOR[:,:,i] = temp2[0,:,:]
		PHI[:,:,i] = temp2[1,:,:]
		PSI[:,:,i] = temp2[2,:,:]
		SCAL[:,:,i] = temp2[3,:,:]

	f.close()
        print 'Data from time = %s' % RECORD1['time']
        print 'mx = %s, my = %s, mz = %s' % (RECORD1['mx'],RECORD1['my'],RECORD1['mz'])
	#Return y, FIELD
	return RECORD1['yfmap']['y'][0,:],VOR,PHI,PSI,SCAL,RECORD1['uvw00']['u00'], \
	 RECORD1['uvw00']['v00'],RECORD1['uvw00']['w00']




#3def calcdmcomp(y,um,rum,Tm):
#3	from numpy import trapz
#3	rhom = 1.0/Tm
#3	r0 = (rhom[0]+rhom[-1])/2.
#3	DU = um.max()-um.min()
#3	Ly = y.max()-y.min()
#3	mom1 = rum[-1]*um[-1]*Ly/2.
#3	mom2 = rum[0]*um[0]*Ly/2.
#3	integ1 = trapz(rum*um,y)
#3	return (mom1 + mom2 - integ1)/(r0*DU**2)

def calcdmcomp(y,um,rum,Tm):
	""" Pantano definition
	"""
	from numpy import trapz
	rhom = 1.0/Tm
	DU = um.max()-um.min()
	#Ly = y.max()-y.min()
	favum = rum/rhom
	r0 = (rhom[0]+rhom[-1])/2.0
	result = 1./(r0*DU**2.0)*trapz(rhom*(0.5*DU-favum)*(0.5*DU+favum),y)
	return result


def calcdw(y,um):
	DU = um.max()-um.min()
	m = (abs(der1(y,um))).max()
	if m ==0:
		return 0.0
	else:
		return DU/m 

def der1(y,u):
	"""computes first derivative using Central Finite Differences
        """
	result = array(u)
        for j in range(len(y)):
 		if j==0:
			result[j]=(u[j+1]-u[j])/(y[j+1]-y[j])
		elif j==(len(y)-1):
			result[j]=(u[j]-u[j-1])/(y[j]-y[j-1])
		else:
			result[j]=(u[j+1]-u[j-1])/(y[j+1]-y[j-1])
	
	return result

def der2(y,u):
	"""Computes second derivative using central differences
	"""
	result = array(u)
	for j in range(len(y)):
		if j==0:
			result[j] = (u[j+2]-2*u[j+1]+u[j])/((y[j+2]-y[j])/2.)**2
		elif j==(len(y)-1):
			result[j] = (u[j-2]-2*u[j-1]+u[j])/((y[j-2]-y[j])/2.)**2
		else:
			result[j]=(u[j+1]-2*u[j]+u[j-1])/((y[j+1]-y[j-1])/2.)**2
        return result




#===============================================================#

def readspe(filename,nvar=12):
	""" This function reads the spe file generated by LOMA
#(yjsp,kx,kz,SPEC) = readspe(filename,nvar)
	(y(jsp),kx,kz,[nz/2,nspec,nvar,nx/2] = readspe (str,int)
	"""
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
                ('nx','uint32'),('ny','uint32'), \
                ('nz','uint32'),('np','uint32'), \
		('nacum','uint32'), \
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)
	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD1...!"
	#else:
    	#	print "Fiel read correctly :)"
        #Save "my"
	my = RECORD1['ny']
	nx = RECORD1['nx'][0]/2
	nz = (RECORD1['nz'][0]+1)/2
	kx = range(nx)*RECORD1['alp']
	kz = range(nz)*RECORD1['bet']
	nacum = RECORD1['nacum']
	#print kx


        rec2 = np.dtype([('dummy1','uint32'), \
                ('jsp','uint32',RECORD1['np']),\
		('yfmap',yfmap,my), \
		('dummy2','uint32')])
	RECORD2=np.fromfile(f,rec2,1)
	nspec = len(RECORD2['jsp'][0])
	#Save y array
	y = RECORD2['yfmap']['y'][0,]
	jsp = RECORD2['jsp'][0,]

	if RECORD2['dummy1'] != RECORD2['dummy2']:
		print "File read not good for RECORD2...!"
		print RECORD2['dummy1']
	#else:
    		#print "Fiel read correctly :)"
        #Need to create stats dtype

	ntotr = nz*nspec*nvar
	print "ntotr=%s,nx=%s,nz=%s,nspec=%s,nvar=%s" \
		 %(ntotr,nx,nz,nspec,nvar)

	temp1 = np.zeros(ntotr)
	temp2 = np.ndarray(shape=(nz,nspec,nvar),\
		dtype = float, order = 'F')
	SPEC = np.ndarray(shape=(nz,nspec,nvar,nx),\
		dtype = float, order = 'F')
	recspec = np.dtype([('dummy1','uint32'), \
		('data','float32',ntotr), \
		('dummy2','uint32')])
	for i in range(nx):
		readrec=np.fromfile(f,recspec,1)
		if readrec['dummy1'] != readrec['dummy2']:
			print "File read NOT good for plane %s...!" %(i+1) 			
		temp1=readrec['data'][:]
		temp2 = np.reshape(temp1,(nz,nspec,nvar),order='F')
		SPEC[:,:,:,i] = temp2[:,:,:]
	f.close()
	SPEC = SPEC/nacum
	
	#Return all
	return y[jsp-1],kx,kz,SPEC 

