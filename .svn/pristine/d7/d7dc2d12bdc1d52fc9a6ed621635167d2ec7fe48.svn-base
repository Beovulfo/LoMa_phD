def create_filenames(varname,nsteps,rksteps=3):
	""" filenames  = create_filenames(varname,nsteps,*rksteps) 
	    list       = create_filenames(str, int)
	    returns a list of filenames live varname.+001001,001002,...,nsteps/003
	Ex:
	print create_filenames("v00.", 2,0)
        >>> ['v00.001','v00.002']	
	"""
	filenames=[]
	for istep in range(nsteps):
		if rksteps != 0:
    			for rkstep in range(rksteps):
        			filename=  varname +'%03d' % (istep+1) + '%03d' % (rkstep+1)
				filenames.append(filename)
		else:
        		filename=  varname +'%03d' % (istep+1)
			filenames.append(filename)
	return filenames

#-----------------------------------------------------------------------------------------------------#
def readASCII(filename):
	""" open a text file with "ncolumns"
	 and reads data, returns a list of lists
	 Important: data must be numbers only and same columns for all lines! 
	[list] = readASCII([str])
	"""
	import numpy as np
	f1 = open(filename,'r')
	file = f1.readlines()
	f1.close()
	#Take one line for info
	ncolumns= len(file[0].split()) 
	nlines = len(file)
	print "Reading file of %s lines and %s columns" %(nlines,ncolumns)
	x = [[] for i in range(ncolumns)]	
	for line in file:
		row = line.split()
		for col in range(len(row)):
			x[col].append(float(row[col].replace('D','E')))
	#return x
	return np.array(x)
			
			
def makeplot(x,col1=0,col2=1):
	import pylab as pl
	fig = pl.figure()
	pl.plot(x[col1,:],x[col2,:],'go')
	#fig.show()
	pl.show()
	print 'Continue computation'

def readfield(filename,my=513):
	""" This function reads the typical unformatted output generated by LOMA
	This case works for SCALAR
	(y,field,u00,w00) = readfield(filename,my)
	(array,array[nxplanes,mz,my,2])= readfield (str,int)
	"""
	import scipy as sc
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),\
		('mx','uint32'),('my','uint32'),('mz','uint32'),\
		('yfmap',yfmap,my), \
		('uw00',uw00,my),
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mx=RECORD1['mx']
	my=RECORD1['my']
	mz=RECORD1['mz']
	ntotr=2*my*mz
	#Create type "recplane"
	recplane = np.dtype([('dummy1','uint32'), \
                 ('data','float32',ntotr), \
                 ('dummy2','uint32')])

	#Read all planes info
	nplanes=mx//2
	FIELD=np.ndarray(shape=(nplanes,mz,my,2),\
		 dtype=float, order='F')
	FIELD.shape
	for i in range(nplanes):
    		readrec = np.fromfile(f,recplane,1)
    		planedata = readrec['data']
    		planedata.shape=(mz,my,2)
    		FIELD[i,:,:]=planedata

	f.close()
	#Return y, FIELD
	return RECORD1['yfmap']['y'][0,:],FIELD,RECORD1['uw00']['u00'][0,:],\
 	RECORD1['uw00']['w00'][0,:]

def read2field(filename,my=513):
	""" This function reads the typical unformatted output generated by LOMA
	This case works for output files (classic vor/phi)
	(y,vor,phi,u00,w00) = read2field(filename,my)
	(array,array[nxplanes,mz,my,2],array[nxplanes,mz,my,2],array(my,2),array(my,2) = read2field (str,int)
	"""
	import scipy as sc
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),\
		('mx','uint32'),('my','uint32'),('mz','uint32'),\
		('yfmap',yfmap,my), \
		('uw00',uw00,my),
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mx=RECORD1['mx']
	my=RECORD1['my']
	mz=RECORD1['mz']
	ntotr=4*my*mz
	#Create type "recplane"
	recplane = np.dtype([('dummy1','uint32'), \
                 ('data','float32',ntotr), \
                 ('dummy2','uint32')])

	#Read all planes info
	nplanes=mx//2
	FIELD1=np.ndarray(shape=(nplanes,mz,my,2),\
		 dtype=float, order='F')
	FIELD2=np.ndarray(shape=(nplanes,mz,my,2),\
		 dtype=float, order='F')
	for i in range(nplanes):
    		readrec = np.fromfile(f,recplane,1)
    		planedata = readrec['data']
    		planedata.shape=(mz,my,4)
		vor = planedata[:,:,0:2]
		vor.shape=(mz,my,2)
		phi = planedata[:,:,2:4]
		phi.shape=(mz,my,2)
    		FIELD1[i,:]=vor
    		FIELD2[i,:]=phi

	f.close()
        print 'Data from time = %s' % RECORD1['time']
        print 'mx = %s, my = %s, mz = %s' % (RECORD1['mx'],RECORD1['my'],RECORD1['mz'])
	#Return y, FIELD
	return RECORD1['yfmap']['y'][0,:],FIELD1,FIELD2,RECORD1['uw00']['u00'], RECORD1['uw00']['w00']

#===============================================================#

def readsta(filename):
	""" This function reads the sta file generated by LOMA
#(y,um,vm,wm,rum,rvm,rwm,Tm,w1m,w2m,w3m,up,vp,wp,uvr,uwr,vwr,w1p,w2p,w3p,Tp) = readsta(filename)
        um,vm,wm,urms,vrms,wrms,uv = readsta(..)
        "..p" variables mean square of the variables (energy)
	(Nvar x array[my]) = readsta (str)
	"""
	import scipy as sc
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('my','uint32'),
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),('nacum','uint32'), \
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)
	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD1...!"
	else:
    		print "Fiel read correctly :)"
        #Save "my"
	my=RECORD1['my']

        rec2 = np.dtype([('dummy1','uint32'), \
		('yfmap',yfmap,my), \
		('dummy2','uint32')])
	RECORD2=np.fromfile(f,rec2,1)

	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD2...!"
	else:
    		print "Fiel read correctly :)"
	#Save y array
	y = RECORD2['yfmap']['y'][0,]
        #Need to create stats dtype
	stats = np.dtype([('um','float64'), \
		('vm' ,'float64'), \
		('wm' ,'float64'), \
                ('rum','float64'), \
                ('rvm','float64'), \
                ('rwm','float64'), \
                ('Tm' ,'float64'), \
                ('w1m','float64'), \
                ('w2m','float64'), \
                ('w3m','float64'), \
                ('up' ,'float64'), \
                ('vp' ,'float64'), \
                ('wp' ,'float64'), \
                ('uvr','float64'), \
                ('uwr','float64'), \
                ('vwr','float64'), \
                ('w1p','float64'), \
                ('w2p','float64'), \
                ('w3p','float64'), \
                ('Tp' ,'float64')])

	nacum = RECORD1['nacum']
	#Create type "recstats"
	recstats = np.dtype([('dummy1','uint32'), \
	 	('data',stats,my), \
		('dummy2','uint32')])

	DATA=np.fromfile(f,recstats,1)
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for STATS...!"
	else:
    		print "Fiel read correctly for STATS :)"
	f.close()
        um = DATA['data']['um'][0,:]/nacum 
        vm = DATA['data']['vm'][0,:]/nacum
        wm = DATA['data']['wm'][0,:]/nacum
	uu = DATA['data']['up'][0,:]/nacum
	vv = DATA['data']['vp'][0,:]/nacum
	ww = DATA['data']['wp'][0,:]/nacum
        urms = (uu-um**2)**0.5
        vrms = (vv-vm**2)**0.5
        wrms = (ww-wm**2)**0.5
        uv = DATA['data']['uvr'][0,:]/nacum
        uv =uv - um*vm
        Tm = DATA['data']['Tm'][0,:]/nacum
	
	#Return all
	return y,                \
	RECORD1['time'],         \
	um, vm, wm, urms,vrms,wrms,uv,nacum
	#DATA['data']['rum'][0,:],\
	#DATA['data']['rvm'][0,:],\
	#DATA['data']['rwm'][0,:],\
	#DATA['data']['Tm'][0,:], \
	#DATA['data']['w1m'][0,:],\
	#DATA['data']['w2m'][0,:],\
	#DATA['data']['w3m'][0,:],\
	#DATA['data']['uwr'][0,:],\
	#DATA['data']['vwr'][0,:],\
	#DATA['data']['w1p'][0,:],\
	#DATA['data']['w2p'][0,:],\
	#DATA['data']['w3p'][0,:],\
	#DATA['data']['Tp'][0,:]

#(y,um,vm,wm,rum,rvm,rwm,Tm,w1m,w2m,w3m,up,vp,wp,uvr,uwr,vwr,w1p,w2p,w3p,Tp) = readfield(filename,my)


def readfieldxz(filename):
	""" 
	This function reads the XZ field generated by TOFIS fortran program.
	(y(jspecy),field,xvec,zvec) = readfieldxz(filename)
	"""
	import scipy as sc
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	#uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('mgalx','uint32'),('my','uint32'),('mgalz','uint32'),\
		('nspec','uint32'),('nacum','uint32'),\
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mgalx=RECORD1['mgalx'][0]
	my=RECORD1['my'][0]
	mgalz=RECORD1['mgalz'][0]
	nspec=RECORD1['nspec'][0]

	print "nspec= %s" % nspec

	rec2 = np.dtype([('dummy1','uint32'), \
 		('jspecy','uint32',nspec),  \
		('yfmap',yfmap,my),	\
		('dummy2','uint32')])
	#READ record2
	RECORD2=np.fromfile(f,rec2,1)

	#Check if record2 is ok...
	if RECORD2['dummy1'] != RECORD2['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	#Save y vector amd jspecy
	y = RECORD2['yfmap']['y'][0,]
        jspecy = RECORD2['jspecy'][0,]



	#Create type "recplane"
	recplaney = np.dtype([('dummy1','uint32'), \
                 ('data','float32',mgalx*mgalz), \
                 ('dummy2','uint32')])

	#Read all planes Y info
	FIELD1=np.ndarray(shape=(nspec,mgalx*mgalz),\
		 dtype=float, order='F')
	for j in range(nspec):
    		readrec = np.fromfile(f,recplaney,1)
    		planeydata = readrec['data']
    		#planeydata.shape=(mgalz,mgalx)
		FIELD1[j,:] = planeydata[:]
		#FIELD1[j,:,:] = planeydata[:,:]
        FIELD1.shape=(nspec,mgalz,mgalx)
	FIELD1=FIELD1.transpose(2,0,1)
	f.close()
        #Create vector X and Z
	Lx = 2*3.1415/RECORD1['alp']
	Lz = 2*3.1415/RECORD1['bet']
	x = np.linspace(-Lx/2.,Lx/2.,mgalx)
	z = np.linspace(-Lz/2.,Lz/2.,mgalz)

        print 'Data from time = %s' % RECORD1['time']
        print 'mgalx = %s, my = %s, mgalz = %s' % (RECORD1['mgalx'], \
		RECORD1['my'],RECORD1['mgalz'])
	#Return y, FIELD
	return RECORD2['yfmap']['y'][0,jspecy-1],jspecy,FIELD1,x,z

#===============================================================#


def readfieldyz(filename):
	""" 
	This function reads the YZ field generated by TOFIS fortran program.
	(field,yvec,zvec) = readfieldxz(filename)
	"""
	import scipy as sc
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	#uw00 = np.dtype([('u00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('mgalx','uint32'),('my','uint32'),('mgalz','uint32'),\
		('nspec','uint32'),('nacum','uint32'),\
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	mgalx=RECORD1['mgalx'][0]
	my=RECORD1['my'][0]
	mgalz=RECORD1['mgalz'][0]
	nspec=RECORD1['nspec'][0]

	print "nspec= %s" % nspec

	rec2 = np.dtype([('dummy1','uint32'), \
 		('jspecy','uint32',nspec),  \
		('yfmap',yfmap,my),	\
		('dummy2','uint32')])
	#READ record2
	RECORD2=np.fromfile(f,rec2,1)

	#Check if record2 is ok...
	if RECORD2['dummy1'] != RECORD2['dummy2']:
		print "File read not good...!"
	else:
    		print "Fiel read correctly :)"

	#Save y vector amd jspecy
	y = RECORD2['yfmap']['y'][0,]
        jspecy = RECORD2['jspecy'][0,]



	#Create type "recplane"
	rectZ = np.dtype([('dummy1','uint32'), \
                 ('data','float32',mgalz), \
                 ('dummy2','uint32')])

	#Read all planes Y info
	FIELD1=np.ndarray(shape=(mgalz,my),\
		 dtype=float, order='F')
	for j in range(my):
    		readrec = np.fromfile(f,rectZ,1)
    		rectZdata = readrec['data']
		FIELD1[:,j] = rectZdata[0,:]

	f.close()
        #Create vector X and Z
	Lx = 2*3.1415/RECORD1['alp']
	Lz = 2*3.1415/RECORD1['bet']
	x = np.linspace(-Lx/2.,Lx/2.,mgalx)
	z = np.linspace(-Lz/2.,Lz/2.,mgalz)

        print 'Data from time = %s' % RECORD1['time']
        print 'mgalx = %s, my = %s, mgalz = %s' % (RECORD1['mgalx'], \
		RECORD1['my'],RECORD1['mgalz'])
	#Return y, FIELD
	return FIELD1,RECORD2['yfmap']['y'][0,:],z

#===============================================================#
def read4field(filename,my=513):
	""" This function reads the typical unformatted output generated by LOMACTE
	This case works for output files (classic vor/phi)
	(y,vor,phi,psi,scal,u00,v00,w00) = read4field(filename,my)
	(array,array[nxplanes,mz,my,2],array[nxplanes,mz,my,2],array(my,2),array(my,2) = read4field (str,int)
	"""
	import scipy as sc
	import numpy as np
	import pylab
	f = open(filename,'rb')
	#Create dtypes for proper reading from Fortran unformatted
	# binary file
	#Declaring types
	yfmap = np.dtype([('y','float64'),('fmap','float64')])
	uvw00 = np.dtype([('u00','float32'),('v00','float32'),('w00','float32')])
	rec1 = np.dtype([('dummy1','uint32'), \
                ('time','float32'),('Re','float32'), \
		('alp','float32'),('bet','float32'), \
		('a0','float32'),\
		('mx','uint32'),('my','uint32'),('mz','uint32'),\
		('yfmap',yfmap,my), \
		('uvw00',uvw00,my),
		('dummy2','uint32')])
	#Read first record
	RECORD1=np.fromfile(f,rec1,1)

	#Check if first record is ok...
	if RECORD1['dummy1'] != RECORD1['dummy2']:
		print "File read not good for RECORD1...!"
	else:
    		print "Fiel read correctly :)"

	mx=RECORD1['mx']
	my=RECORD1['my']
	mz=RECORD1['mz']
	ntotr  = 8*my*mz
        nfield = 2*my*mz
        #plane = np.ndarray(shape=(4,2*my,mz),dtype=float,order='F')
	#Create type "recplane"
	recplane = np.dtype([('dummy1','uint32'), \
                 ( 'data','float32',ntotr), \
                 ('dummy2','uint32')])

	#Read all planes info
	nplanes=mx//2

	temp1 = np.zeros(4*2*my*mz)
	temp2 = np.ndarray(shape=(4,2*my,mz),\
		 dtype=float, order='F')
	VOR = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')
	PHI = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')
	PSI = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')
	SCAL = np.ndarray(shape=(2*my,mz,nplanes),\
		 dtype=float, order='F')

	for i in range(nplanes):
		readrec = np.fromfile(f,recplane,1)
		if recplane['dummy1'] != recplane['dummy2']:
			print "File read not good for plane %s ...!" % i
		else:
    			print "Fiel read correctly for plane %s :)" % i
		temp1 = readrec['data'][:]
		temp2 = np.reshape(temp1,(4,2*my,mz),order='F')
		VOR[:,:,i] = temp2[0,:,:]
		PHI[:,:,i] = temp2[1,:,:]
		PSI[:,:,i] = temp2[2,:,:]
		SCAL[:,:,i] = temp2[3,:,:]

	f.close()
        print 'Data from time = %s' % RECORD1['time']
        print 'mx = %s, my = %s, mz = %s' % (RECORD1['mx'],RECORD1['my'],RECORD1['mz'])
	#Return y, FIELD
	return RECORD1['yfmap']['y'][0,:],VOR,PHI,PSI,SCAL,RECORD1['uvw00']['u00'], \
	 RECORD1['uvw00']['v00'],RECORD1['uvw00']['w00']




